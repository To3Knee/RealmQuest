"""
RealmQuest API - Campaign / System Manager
Version: v18.2.11
Purpose:
- Provide System Config, Env, Audio Matrix, Auth Lock/Unlock, and Container Control endpoints
- Designed for Portal to proxy requests via /api -> rq-api:8000

Notes:
- This file defines an APIRouter named `router`.
- main.py should include this with: app.include_router(router, prefix="/system")
- No UI redesign assumptions; endpoints are backward compatible where practical.
"""

from __future__ import annotations

from fastapi import APIRouter, HTTPException, Body
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from typing import Any, Dict, List, Optional
from pathlib import Path
import os
import re
import json
import time
import subprocess
import urllib.request
import urllib.error

# Optional deps (present in the container image in RealmQuest builds)
try:
    import docker  # type: ignore
except Exception:  # pragma: no cover
    docker = None  # type: ignore

try:
    from pymongo import MongoClient  # type: ignore
except Exception:  # pragma: no cover
    MongoClient = None  # type: ignore


router = APIRouter()

# ---------------------------- Storage (Mongo) ----------------------------

def _mongo():
    if MongoClient is None:
        return None
    mongo_url = os.environ.get("MONGO_URL", "mongodb://realmquest-mongo:27017")
    client = MongoClient(mongo_url, serverSelectionTimeoutMS=1500)
    return client

def _cfg_collection():
    client = _mongo()
    if client is None:
        return None
    db = client[os.environ.get("MONGO_DB", "realmquest")]
    return db["system_config"]

def _strip_mongo(doc: Dict[str, Any]) -> Dict[str, Any]:
    doc = dict(doc or {})
    doc.pop("_id", None)
    return doc

# ---------------------------- Auth (PIN lock) ----------------------------

AUTH_LOCKED: bool = False

def _admin_pin() -> str:
    return str(os.environ.get("ADMIN_PIN", "")).strip()

def _has_pin() -> bool:
    return _admin_pin() != ""

@router.get("/auth/status")
def auth_status() -> Dict[str, Any]:
    return {"locked": bool(AUTH_LOCKED), "has_pin": _has_pin()}

@router.post("/auth/lock")
def auth_lock() -> Dict[str, Any]:
    global AUTH_LOCKED
    # If no PIN is configured, locking is a no-op but returns status.
    if _has_pin():
        AUTH_LOCKED = True
    return {"locked": bool(AUTH_LOCKED), "has_pin": _has_pin()}

@router.post("/auth/unlock")
def auth_unlock(payload: Dict[str, Any] = Body(default_factory=dict)) -> Dict[str, Any]:
    global AUTH_LOCKED
    if not _has_pin():
        AUTH_LOCKED = False
        return {"ok": True, "locked": False, "has_pin": False}

    pin = str((payload or {}).get("pin", "")).strip()
    if not pin:
        raise HTTPException(status_code=400, detail="Missing pin")

    if pin != _admin_pin():
        raise HTTPException(status_code=401, detail="Invalid pin")

    AUTH_LOCKED = False
    return {"ok": True, "locked": False, "has_pin": True}

# ---------------------------- Env file helpers ----------------------------

ENV_FILE_PATH = Path(os.environ.get("REALMQUEST_ENV_PATH", "/opt/RealmQuest/.env"))

_SAFE_KEY_RE = re.compile(r"^[A-Z0-9_]{1,128}$")

def _safe_key(k: str) -> str:
    k = (k or "").strip()
    if not _SAFE_KEY_RE.match(k):
        return ""
    return k

def _read_env_file(path: Path) -> Dict[str, str]:
    if not path.exists():
        return {}
    out: Dict[str, str] = {}
    for raw in path.read_text(errors="ignore").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = k.strip()
        if not _safe_key(k):
            continue
        out[k] = v.strip()
    return out

def _write_env_file(path: Path, data: Dict[str, str]) -> None:
    # Preserve existing non-key lines (comments/blank) and order where possible.
    existing_lines: List[str] = []
    existing_keys: set[str] = set()

    if path.exists():
        for raw in path.read_text(errors="ignore").splitlines():
            if "=" in raw and not raw.strip().startswith("#"):
                k = raw.split("=", 1)[0].strip()
                if _safe_key(k):
                    existing_keys.add(k)
                    # Replace later
                    existing_lines.append(k)
                    continue
            existing_lines.append(raw)

    # Build final output
    rendered: List[str] = []
    used: set[str] = set()

    for token in existing_lines:
        if token in existing_keys:
            # this token is a key placeholder
            val = data.get(token, None)
            if val is None:
                # deleted
                continue
            rendered.append(f"{token}={val}")
            used.add(token)
        else:
            rendered.append(token)

    # Append new keys
    for k in sorted(data.keys()):
        if k in used:
            continue
        rendered.append(f"{k}={data[k]}")

    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(rendered).rstrip() + "\n")

def set_key(path: Path, key: str, value: str) -> None:
    env = _read_env_file(path)
    env[key] = value
    _write_env_file(path, env)

def unset_key(path: Path, key: str) -> None:
    env = _read_env_file(path)
    env.pop(key, None)
    _write_env_file(path, env)

def _env_as_list(path: Path) -> List[Dict[str, str]]:
    env = _read_env_file(path)
    return [{"key": k, "value": v} for k, v in sorted(env.items())]

@router.get("/env/all")
def env_all_get():
    # If locked, do not leak env values to the portal.
    if _has_pin() and AUTH_LOCKED:
        return []
    return _env_as_list(ENV_FILE_PATH)

@router.post("/env/all")
def env_all_post():
    # Backward compatibility: some portals used POST.
    return env_all_get()

@router.post("/env")
def env_set(payload: Dict[str, Any] = Body(default_factory=dict)):
    if _has_pin() and AUTH_LOCKED:
        raise HTTPException(status_code=401, detail="Locked")

    # Accept both:
    # 1) {"key":"FOO","value":"bar"}
    # 2) {"FOO":"bar"}
    key = _safe_key(str((payload or {}).get("key", "")))
    if key:
        val = str((payload or {}).get("value", "")).strip()
    else:
        # single-key dict style
        if not payload or len(payload.keys()) != 1:
            raise HTTPException(status_code=400, detail="Missing key")
        k = list(payload.keys())[0]
        key = _safe_key(str(k))
        if not key:
            raise HTTPException(status_code=400, detail="Invalid key")
        val = str(payload[k]).strip()

    if val == "":
        unset_key(ENV_FILE_PATH, key)
        return {"ok": True, "key": key, "deleted": True}

    set_key(ENV_FILE_PATH, key, val)
    return {"ok": True, "key": key, "value": val}

@router.delete("/env/{key}")
def env_delete(key: str):
    if _has_pin() and AUTH_LOCKED:
        raise HTTPException(status_code=401, detail="Locked")

    key = _safe_key(key)
    if not key:
        raise HTTPException(status_code=400, detail="Invalid key")

    unset_key(ENV_FILE_PATH, key)
    return {"ok": True, "key": key, "deleted": True}

@router.get("/env/{key}")
def env_get(key: str):
    if _has_pin() and AUTH_LOCKED:
        raise HTTPException(status_code=401, detail="Locked")

    key = _safe_key(key)
    if not key:
        raise HTTPException(status_code=400, detail="Invalid key")

    env = _read_env_file(ENV_FILE_PATH)
    return {"key": key, "value": env.get(key, "")}

@router.post("/env/{key}")
def env_set_by_key(key: str, payload: Dict[str, Any] = Body(default_factory=dict)):
    # Backward compatibility with older UI.
    if _has_pin() and AUTH_LOCKED:
        raise HTTPException(status_code=401, detail="Locked")

    key = _safe_key(key)
    if not key:
        raise HTTPException(status_code=400, detail="Invalid key")
    val = str((payload or {}).get("value", "")).strip()
    if val == "":
        unset_key(ENV_FILE_PATH, key)
        return {"ok": True, "key": key, "deleted": True}
    set_key(ENV_FILE_PATH, key, val)
    return {"ok": True, "key": key, "value": val}

# ---------------------------- System Config ----------------------------

def _default_system_config() -> Dict[str, Any]:
    return {
        "config_id": "system_config",
        "active_campaign": "the_collision_stone",
        "llm_provider": "Gemini-Flash",
        "art_style": "Cinematic Fantasy",
    }

class Archetype(BaseModel):
    id: str
    label: str
    voice_id: str = ""

class Soundscape(BaseModel):
    id: str
    label: str
    track_id: str = ""

class AudioRegistry(BaseModel):
    config_id: str = "audio_registry"
    dmName: str = "DM"
    dmVoice: str = ""
    archetypes: List[Archetype] = Field(default_factory=list)
    soundscapes: List[Soundscape] = Field(default_factory=list)

def _default_audio_registry() -> Dict[str, Any]:
    return AudioRegistry(
        archetypes=[
            Archetype(id="villain", label="The Villain"),
            Archetype(id="merchant", label="The Merchant"),
            Archetype(id="child", label="The Child"),
        ],
        soundscapes=[
            Soundscape(id="combat", label="Combat Encounter"),
            Soundscape(id="tavern", label="Tavern Ambience"),
        ],
    ).model_dump()

def _get_or_init(collection, config_id: str, default_doc: Dict[str, Any]) -> Dict[str, Any]:
    if collection is None:
        # No mongo: keep in memory
        return dict(default_doc)

    doc = collection.find_one({"config_id": config_id}) or None
    if not doc:
        collection.replace_one({"config_id": config_id}, default_doc, upsert=True)
        return dict(default_doc)
    return _strip_mongo(doc)

@router.get("/config")
def get_system_config():
    if _has_pin() and AUTH_LOCKED:
        # Still allow minimal status without leaking config
        return _default_system_config() | {"audio_registry": _default_audio_registry()}

    col = _cfg_collection()
    sys_cfg = _get_or_init(col, "system_config", _default_system_config())
    audio_cfg = _get_or_init(col, "audio_registry", _default_audio_registry())
    sys_cfg["audio_registry"] = audio_cfg
    return sys_cfg

@router.post("/config")
def set_system_config(payload: Dict[str, Any] = Body(default_factory=dict)):
    if _has_pin() and AUTH_LOCKED:
        raise HTTPException(status_code=401, detail="Locked")

    col = _cfg_collection()
    existing = get_system_config()
    # Keep audio_registry stored separately; ignore if passed here
    payload = dict(payload or {})
    payload.pop("audio_registry", None)
    merged = dict(existing)
    merged.update(payload)
    merged["config_id"] = "system_config"
    if col is not None:
        col.replace_one({"config_id": "system_config"}, merged, upsert=True)
    return {"ok": True, "config": merged}

# ---------------------------- Audio Matrix ----------------------------

def _http_get_json(url: str, timeout_s: float = 2.5):
    req = urllib.request.Request(url, headers={"Accept": "application/json"})
    with urllib.request.urlopen(req, timeout=timeout_s) as resp:
        raw = resp.read()
    return json.loads(raw.decode("utf-8", errors="ignore") or "null")

@router.get("/audio/voices")
def list_voices():
    # Portal expects a list of {id, name}
    # Provide ElevenLabs voice list if ELEVENLABS_API_KEY is present; otherwise empty list.
    key = os.environ.get("ELEVENLABS_API_KEY", "").strip()
    if not key:
        return []
    try:
        data = _http_get_json("https://api.elevenlabs.io/v1/voices", timeout_s=4.0)
        voices = data.get("voices") or []
        out = [{"id": v.get("voice_id", ""), "name": v.get("name", "")} for v in voices]
        return [v for v in out if v["id"] and v["name"]]
    except Exception:
        # Do not fail Audio Matrix entirely if provider errors
        return []

def _kenku_base() -> str:
    # From inside rq-api container, this hostname resolves via compose network
    return os.environ.get("KENKU_URL", "http://realmquest-kenku:3333").rstrip("/")

def _probe_kenku_tracks() -> List[Dict[str, str]]:
    """
    Kenku-FM/alternative builds differ wildly. We probe a small set of common endpoints and normalize.
    Returns list of {id, name}.
    """
    base = _kenku_base()
    candidates = [
        "/api/media",
        "/api/medias",
        "/api/library/media",
        "/api/library/medias",
        "/api/sounds",
        "/api/tracks",         # some builds
        "/media",
        "/medias",
    ]
    for path in candidates:
        url = f"{base}{path}"
        try:
            data = _http_get_json(url, timeout_s=2.0)
        except Exception:
            continue

        # Normalize a list found somewhere inside the response
        items = None
        if isinstance(data, list):
            items = data
        elif isinstance(data, dict):
            for k in ("items", "data", "media", "medias", "tracks", "results"):
                if isinstance(data.get(k), list):
                    items = data.get(k)
                    break
        if not isinstance(items, list):
            continue

        out: List[Dict[str, str]] = []
        for it in items:
            if not isinstance(it, dict):
                continue
            _id = str(it.get("id") or it.get("_id") or it.get("uuid") or it.get("mediaId") or "").strip()
            name = str(it.get("name") or it.get("title") or it.get("label") or "").strip()
            if _id and name:
                out.append({"id": _id, "name": name})
        if out:
            # stable ordering
            out.sort(key=lambda x: x["name"].lower())
            return out
    return []

@router.get("/audio/kenku/tracks")
def kenku_tracks():
    # If Kenku is down, return [] rather than killing the page.
    try:
        return _probe_kenku_tracks()
    except Exception:
        return []

class AudioSavePayload(BaseModel):
    dmName: Optional[str] = "DM"
    dmVoice: Optional[str] = ""
    archetypes: List[Dict[str, Any]] = Field(default_factory=list)
    soundscapes: List[Dict[str, Any]] = Field(default_factory=list)

@router.post("/audio/save")
def save_audio(payload: AudioSavePayload):
    if _has_pin() and AUTH_LOCKED:
        raise HTTPException(status_code=401, detail="Locked")

    # Normalize
    reg = _default_audio_registry()
    reg["dmName"] = str(payload.dmName or "DM").strip() or "DM"
    reg["dmVoice"] = str(payload.dmVoice or "").strip()
    reg["archetypes"] = payload.archetypes or []
    reg["soundscapes"] = payload.soundscapes or []
    reg["config_id"] = "audio_registry"

    col = _cfg_collection()
    if col is not None:
        col.replace_one({"config_id": "audio_registry"}, reg, upsert=True)
    return {"ok": True, "audio_registry": reg}

# ---------------------------- Container control (logs/restart) ----------------------------

SERVICE_TO_CONTAINER = {
    "rq-api": "realmquest-api",
    "rq-portal": "realmquest-portal",
    "rq-bot": "realmquest-bot",
    "rq-scribe": "realmquest-scribe",
    "rq-kenku": "realmquest-kenku",
    "rq-chroma": "realmquest-chroma",
    "rq-mongo": "realmquest-mongo",
    "rq-redis": "realmquest-redis",
}

def _container_name(service: str) -> str:
    service = (service or "").strip()
    if service in SERVICE_TO_CONTAINER:
        return SERVICE_TO_CONTAINER[service]
    # Allow direct container name for convenience
    if service.startswith("realmquest-"):
        return service
    return service

def _docker_client():
    if docker is None:
        return None
    try:
        return docker.from_env()
    except Exception:
        return None

@router.get("/control/logs/{service}")
def control_logs(service: str, tail: int = 400):
    name = _container_name(service)
    tail = max(10, min(int(tail or 400), 5000))

    text = ""
    client = _docker_client()
    if client is not None:
        try:
            c = client.containers.get(name)
            text = c.logs(tail=tail).decode("utf-8", errors="ignore")
        except Exception:
            text = ""
    else:
        # Fallback (requires docker CLI inside container)
        try:
            out = subprocess.check_output(["docker", "logs", f"--tail={tail}", name], stderr=subprocess.STDOUT)
            text = out.decode("utf-8", errors="ignore")
        except Exception:
            text = ""

    if not text.strip():
        text = "No logs available."
    return {"logs": text}

@router.post("/control/restart/{service}")
def control_restart(service: str):
    name = _container_name(service)

    client = _docker_client()
    if client is not None:
        try:
            c = client.containers.get(name)
            c.restart()
            return {"ok": True, "service": service, "container": name}
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    # Fallback: docker cli
    try:
        subprocess.check_call(["docker", "restart", name])
        return {"ok": True, "service": service, "container": name}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
